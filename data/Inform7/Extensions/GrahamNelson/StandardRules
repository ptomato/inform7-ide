Version 1/061217 of the Standard Rules by Graham Nelson begins here.

"The Standard Rules, included in every project, define the basic framework
of kinds, actions and phrases which make Inform what it is."

Document ACTIONS at doc90.
Document ACTIVITIES at doc256.
Document ARSUMMARY at doc173.
Document EXTACTIVITIES at doc260.
Document HEADINGS at doc15.
Document KINDS at doc31.
Document KINDSVALUE at doc61.
Document LCARDS at doc317.
Document NEWRULEBOOKS at doc294.
Document PHRASES at doc153.
Document ROOMPLAYBEGINS at doc127.
Document SCENESINTRO at doc143.
Document act_all at doc283.
Document act_amuse at doc286.
Document act_banner at doc284.
Document act_clarify at doc277.
Document act_con at doc263.
Document act_csl at doc273.
Document act_darkdesc at doc272.
Document act_darkname at doc271.
Document act_details at doc268.
Document act_ds at doc276.
Document act_gt at doc267.
Document act_implicitly at doc281.
Document act_lc at doc266.
Document act_lni at doc275.
Document act_nowdark at doc270.
Document act_obit at doc285.
Document act_parsererror at doc282.
Document act_pn at doc264.
Document act_ppn at doc265.
Document act_reading at doc280.
Document act_smn at doc279.
Document act_startvm at doc287.
Document act_toodark at doc269.
Document act_which at doc278.
Document act_wpa at doc274.
Document kind_backdrop at doc35.
Document kind_device at doc40.
Document kind_door at doc38.
Document kind_person at doc43.
Document kind_player's at doc47.
Document kind_time at doc132.
Document kind_vehicle at doc42.
Document ph_allow at doc185.
Document ph_blankout at doc229.
Document ph_boxed at doc78.
Document ph_carryout at doc260.
Document ph_change at doc109.
Document ph_changep at doc112.
Document ph_changev at doc113.
Document ph_chooserow at doc224.
Document ph_consents at doc156.
Document ph_consider at doc301.
Document ph_end at doc130.
Document ph_follow at doc294.
Document ph_future at doc137.
Document ph_group at doc266.
Document ph_happening at doc146.
Document ph_holder at doc123.
Document ph_if at doc157.
Document ph_ignore at doc300.
Document ph_list at doc164.
Document ph_minspart at doc136.
Document ph_move at doc115.
Document ph_nearest at doc134.
Document ph_nothing at doc154.
Document ph_numblank at doc229.
Document ph_numrows at doc221.
Document ph_omit at doc264.
Document ph_otherwise at doc160.
Document ph_plus at doc206.
Document ph_random at doc124.
Document ph_remove at doc117.
Document ph_repeat at doc161.
Document ph_result at doc166.
Document ph_runthrough at doc162.
Document ph_say at doc74.
Document ph_sayif at doc71.
Document ph_scope at doc276.
Document ph_sort at doc230.
Document ph_stop at doc92.
Document ph_succeeds at doc296.
Document ph_surrounds at doc111.
Document ph_tabrepeat at doc225.
Document ph_thereis at doc226.
Document ph_timeshift at doc135.
Document ph_try at doc93.
Document ph_tsince at doc145.
Document ph_types at doc73.
Document ph_while at doc158.
Document ph_yes at doc166.
Document rules_after at doc94.
Document rules_before at doc92.
Document rules_dtpm at doc253.
Document rules_et at doc131.
Document rules_fail at doc176.
Document rules_instead at doc91.
Document rules_internal at doc303.
Document rules_per at doc175.
Document rules_proc at doc299.
Document rules_ri at doc185.
Document rules_wpb at doc127.
Document rules_wpe at doc130.
Document var_command at doc280.
Document var_location at doc64.
Document var_noun at doc99.
Document var_particular at doc263.
Document var_person_asked at doc174.
Document var_person_reaching at doc187.
Document var_prompt at doc110.
Document var_reason at doc176.
Document var_score at doc128.
Document var_sl at doc111.
Document var_time at doc132.
Document var_understood at doc245.
Document visibility at doc188.

Use MAX_ARRAYS of 1500.
Use MAX_CLASSES of 200.
Use MAX_VERBS of 300.
Use MAX_LABELS of 10000.
Use MAX_ZCODE_SIZE of 50000.
Use MAX_STATIC_DATA of 50000.
Use MAX_PROP_TABLE_SIZE of 50000.
Use MAX_INDIV_PROP_TABLE_SIZE of 20000.
Use MAX_STACK_SIZE of 65536.
Use MAX_SYMBOLS of 20000.


Part SR1 - Kinds


Section SR1/1 - Primitive Kinds

[The kind "kind" is not created here but by NI itself. The first through
to tenth kinds created now follow: they must not be reordered or moved.]

A room is a kind.
A thing is a kind.
A direction is a kind.
A door is a kind of thing.
A container is a kind of thing.
A supporter is a kind of thing.
A backdrop is a kind of thing.
The plural of person is people.
The plural of person is persons.
A person is a kind of thing.
A region is a kind.


Section SR1/2 - Rooms

The specification of room is "Represents geographical locations, both indoor
and outdoor, which are not necessarily areas in a building. A player in one
room is mostly unable to sense, or interact with, anything in a different room.
Rooms are arranged in a map."

A room can be lighted or dark. A room is usually lighted.
A room can be visited or unvisited. A room is usually unvisited.
A room has an object called map region. A room has a text called
description. A room has a text called printed name.

Include (-
  with n_to 0, ne_to 0, e_to 0, se_to 0, s_to 0, sw_to 0, w_to 0, nw_to 0,
  u_to 0, d_to 0, in_to 0, out_to 0,
-) when defining a room.

Definition: A room is adjacent if it is adjacent to the location.

Section SR1/3 - Things

The specification of thing is "Represents anything interactive in the model
world that is not a room. People, pieces of scenery, furniture, doors and
mislaid umbrellas might all be examples, and so might more surprising things
like the sound of birdsong or a shaft of sunlight."

A thing has a text called a description. A thing has a text called
an initial appearance. A thing has a text called printed name. A thing
has a text called a printed plural name. A thing has a text called
an inventory listing. A thing has a text called an indefinite article.

A thing has an object called a matching key.

A thing can be enterable.

A thing can be lit or unlit. A thing is usually unlit.

A thing can be edible or inedible. A thing is usually inedible.

A thing can be opaque or transparent. A thing is usually opaque.

A thing can be described or undescribed. A thing is usually described.

A thing can be fixed in place or portable. A thing is usually portable.

A thing can be scenery. A thing is usually not scenery. Scenery is usually
fixed in place.

A thing can be wearable. A thing is usually not wearable.

A thing can be handled.

A thing can be pushable between rooms.

Include (-
  with before [;
      PushDir: AllowPushDir(); rtrue;
  ],
  with add_to_scope I7_ScopeParts,
  with component_parent nothing, component_sibling nothing, component_child nothing,
-) when defining a thing.

A thing can be an Inform library door. A thing can be an Inform library
container. A thing can be an Inform library supporter. A thing can be
Inform library switchable. A thing can be an Inform library animate object.
A thing can be an Inform library male.

A thing can be marked for listing or unmarked for listing. A thing is usually
unmarked for listing.

A thing can be mentioned or unmentioned.

A thing can be initially carried.

The verb to be able to see (he is seen) implies the visibility relation.

The verb to be able to touch (he is touched) implies the touchability relation.

The verb to conceal (he conceals, they conceal, he concealed, it is concealed,
he is concealing) implies the concealment relation.

The verb to enclose (he encloses, they enclose, he enclosed, it is enclosed,
he is enclosing) implies the enclosure relation.

Definition: Something is visible if the player can see it.

Definition: Something is touchable if the player can touch it.

Definition: Something is invisible if the player cannot see it.

Definition: Something is untouchable if the player cannot touch it.

Definition: Something is concealed if the holder of it conceals it.

Definition: Something is unconcealed if the holder of it does not conceal it.

Definition: Something is on-stage if the world model includes it.

Definition: Something is off-stage if the world model does not include it.

Section SR1/4 - Doors

The specification of door is "Represents a conduit joining two rooms, most
often a door or gate but sometimes a plank bridge, a slide or a hatchway.
Usually visible and operable from both sides (for instance if you write
'The blue door is east of the Ballroom and west of the Garden.'), but
sometimes only one-way (for instance if you write 'East of the Ballroom is
the long slide. Through the long slide is the cellar.')."

A door is always an Inform library door.
A door can be open or closed.
A door is usually closed. A door can be openable or unopenable.
A door is usually openable.
A door can be lockable. A door is usually not lockable.
A door can be locked or unlocked. A door is usually unlocked.
A door is usually fixed in place.
A door is never pushable between rooms.
A door has an object called an other side.
Leading-through relates one room (called the other side) to various doors.
The verb to be through implies the leading-through relation.


Section SR1/5 - Containers and supporters

The specification of container is "Represents something into which portable
things can be put, such as a teachest or a handbag. Something with a really
large immobile interior, such as the Albert Hall, had better be a room
instead."

A container is always an Inform library container.
A container can be open or closed. A container is usually open.
A container can be openable or unopenable. A container is usually unopenable.
A container can be lockable. A container is usually not lockable.
A container can be locked or unlocked. A container is usually
unlocked.
A container has a number called carrying capacity.

Lock-fitting relates one thing (called the matching key) to various things.
The verb to unlock (it unlocks, they unlock, it unlocked, it is unlocked)
implies the lock-fitting relation.

A player's holdall is a kind of container. The specification of
player's holdall is "Represents a container which the player can
carry around as a sort of rucksack, into which spare items are
automatically stowed away."

A player's holdall is always portable. A player's holdall
is usually openable.

Include (-
Global SACK_OBJECT;
Constant RUCKSACK_CLASS = K10_player_s_holdall;
-) before the library.

The specification of supporter is "Represents a surface on which things can be
placed, such as a table."

A supporter is always an Inform library supporter.
A supporter is always transparent.
A supporter is usually fixed in place.
A supporter has a number called carrying capacity.


Section SR1/6 - Devices

A device is a kind of thing. A device is always Inform library switchable.
A device can be switched on or switched off. A device is usually switched off.

The specification of device is "Represents a machine or contrivance of some
kind which can be switched on or off."


Section SR1/7 - Directions

The specification of direction is "Represents a direction of movement, such
as northeast or down. At present Inform 7 does not support the creation
of new directions, but it will do in the final release."

A direction has a direction called an opposite. A direction has a text called an
Inform property. A direction has a text called an Inform object.

A direction can be marked for listing or unmarked for listing. A direction is
usually unmarked for listing.

The north is a direction with opposite south, Inform property "n_to" and Inform object "n_obj".
The northeast is a direction with opposite southwest, Inform property "ne_to" and Inform object "ne_obj".
The northwest is a direction with opposite southeast, Inform property "nw_to" and Inform object "nw_obj".
The south is a direction with opposite north, Inform property "s_to" and Inform object "s_obj".
The southeast is a direction with opposite northwest, Inform property "se_to" and Inform object "se_obj".
The southwest is a direction with opposite northeast, Inform property "sw_to" and Inform object "sw_obj".
The east is a direction with opposite west, Inform property "e_to" and Inform object "e_obj".
The west is a direction with opposite east, Inform property "w_to" and Inform object "w_obj".
The up is a direction with opposite down, Inform property "u_to" and Inform object "u_obj".
The down is a direction with opposite up, Inform property "d_to" and Inform object "d_obj".
The inside is a direction with opposite outside, Inform property "in_to" and Inform object "in_obj".
The outside is a direction with opposite inside, Inform property "out_to" and Inform object "out_obj".

Include (- class CompassDirection, -) when defining a direction.
Include (- with name 'n//' 'north', door_dir n_to, -) when defining the north.
Include (- with name 'ne' 'northeast', door_dir ne_to, -) when defining the northeast.
Include (- with name 'nw' 'northwest', door_dir nw_to, -) when defining the northwest.
Include (- with name 's//' 'south', door_dir s_to, -) when defining the south.
Include (- with name 'se' 'southeast', door_dir se_to, -) when defining the southeast.
Include (- with name 'sw' 'southwest', door_dir sw_to, -) when defining the southwest.
Include (- with name 'e//' 'east', door_dir e_to, -) when defining the east.
Include (- with name 'w//' 'west', door_dir w_to, -) when defining the west.
Include (- with name 'u//' 'up', door_dir u_to, -) when defining up.
Include (- with name 'd//' 'down', door_dir d_to, -) when defining down.
Include (- with name 'in//' 'inside', door_dir in_to, -) when defining inside.
Include (- with name 'out//' 'outside', door_dir out_to, -) when defining outside.

The verb to be above implies the mapping-up relation.
The verb to be below implies the mapping-down relation.
The verb to be mapped above implies the mapping-up relation.
The verb to be mapped below implies the mapping-down relation.
The verb to be mapped north of implies the mapping-north relation.
The verb to be mapped northeast of implies the mapping-northeast relation.
The verb to be mapped northwest of implies the mapping-northwest relation.
The verb to be mapped east of implies the mapping-east relation.
The verb to be mapped south of implies the mapping-south relation.
The verb to be mapped southeast of implies the mapping-southeast relation.
The verb to be mapped southwest of implies the mapping-southwest relation.
The verb to be mapped west of implies the mapping-west relation.
The verb to be mapped inside implies the mapping-inside relation.
The verb to be mapped outside implies the mapping-outside relation.


Section SR1/8 - People, men and women

A person is always an Inform library animate object.
A person can be female or male. A person is usually male.
A person has a number called carrying capacity.
The carrying capacity of a person is usually 100.

The specification of person is "Despite the name, not necessarily
a human being, but anything animate enough to envisage having a
conversation with, or bartering with."

An animal is a kind of person.
The specification of animal is "Represents an animal, or at any
rate a non-human living creature reasonably large and possible
to interact with: a giant Venus fly-trap might qualify, but not
a patch of lichen."

The plural of man is men. The plural of woman is women.

A man is a kind of person.
The specification of man is "Represents a man, boy or sometimes
an animal which can be referred to as 'him'."
A man is always Inform library male. A man is always male.

A woman is a kind of person. A woman is always female.

The specification of woman is "Represents a woman, girl or sometimes
an animal which can be referred to as 'her'."

A person can be neuter. A person is usually not neuter. A woman is
never neuter. A man is never neuter. Neuter translates into Inform as
"neuter".


Section SR1/8a - Player-characters - unindexed


A player-character is a kind of person.

The specification of player-character is "Represents a body through
which the game can be played. In most games there is only one of these,
normally called 'yourself'." The description of a player-character is
usually "As good-looking as ever."

Include (-
  with before NULL, after NULL, life NULL, each_turn NULL,
       time_out NULL, before_implicit NULL,
       parse_name 0,
       orders 0, number 0,
  has  proper transparent,
-) when defining a player-character.

The player is a player-character that varies.

The yourself is an undescribed player-character.
The Inform object of yourself is "selfobj".


Section SR1/9 - Vehicles

A vehicle is a kind of container.
A vehicle is always enterable.
A vehicle is usually not portable.
Include (- with before [; Go: return 1; ], -) when defining a vehicle.


Section SR1/10 - Backdrops

The specification of backdrop is "Represents an aspect of the landscape
or architecture which extends across more than one room: for instance,
a stream, the sky or a long carpet."

A backdrop is usually scenery.
A backdrop is always fixed in place.


Section SR1/11 - Inform 6 equivalents

The description translates into Inform as "description".
Initial appearance translates into Inform as "initial".
The printed name translates into Inform as "short_name".
The printed plural name translates into Inform as "plural".
Lit translates into Inform as "light".
Lighted translates into Inform as "light".
Switched on translates into Inform as "on".
Score for visiting translates into Inform as "score".
Score translates into Inform as "score".
Open translates into Inform as "open".
Openable translates into Inform as "openable".
Locked translates into Inform as "locked".
Lockable translates into Inform as "lockable".
The matching key translates into Inform as "with_key".
Transparent translates into Inform as "transparent".
Fixed in place translates into Inform as "static".
Worn translates into Inform as "worn".
Edible translates into Inform as "edible".
Enterable translates into Inform as "enterable".
Undescribed translates into Inform as "concealed".
Scenery translates into Inform as "scenery".
Inform library door translates into Inform as "door".
Inform library supporter translates into Inform as "supporter".
Inform library container translates into Inform as "container".
Wearable translates into Inform as "clothing".
Inform library switchable translates into Inform as "switchable".
The other side translates into Inform as "door_to".
Visited translates into Inform as "visited".
Inform library animate object translates into Inform as "animate".
Inform library male translates into Inform as "male".
Female translates into Inform as "female".
Pushable between rooms translates into Inform as "pushable".
Carrying capacity translates into Inform as "capacity".
Indefinite article translates into Inform as "article".
Inventory listing translates into Inform as "invent".
Initially carried translates into Inform as "initially_carried".
Handled translates into Inform as "moved".
Marked for listing translates into Inform as "workflag".
Map region translates into Inform as "I7_Map_Region".
Mentioned translates into Inform as "I7_mentioned".


Section SR1/12 - Situation

The location -- documented at var_location -- is an object that varies.
The score -- documented at var_score -- is a number that varies.
The maximum score is a number that varies.
The turn count is a number that varies.
The time of day -- documented at var_time -- is a time that varies.


Section SR1/13 - Current action

The noun -- documented at var_noun -- is an object that varies.
The second noun is an object that varies.
The person asked -- documented at var_person_asked -- is an object that varies.
The reason the action failed -- documented at var_reason -- is a rule that varies.
The item described is an object that varies.


Section SR1/14 - Used when ruling on accessibility

The person reaching -- documented at var_person_reaching -- is an object that varies.
[The object in question is an object that varies.]
The container in question is an object that varies.
[The this object is an object that varies.]
The particular possession -- documented at var_particular -- is a thing that varies.


Section SR1/15 - Used when understanding typed commands

The player's command -- documented at var_command -- is a snippet that varies.
The matched text is a snippet that varies.
The number understood -- documented at var_understood -- is a number that varies.
The time understood is a time that varies.
The topic understood is a snippet that varies.


Section SR1/16 - Presentation on screen

The command prompt -- documented at var_prompt -- is a text that varies.
The left hand status line -- documented at var_sl -- is a text that varies.
The right hand status line is a text that varies.


Section SR1/17 - Implications

Locked is usually lockable.


Part SR2 - Rules

Section SR2/1 - Standard Rulebooks

[Do not alter the following list unless matching changes have been
made within the NI compiler.]
Action-processing rules is a rulebook. [0]
Before rules is a rulebook. [1]
Instead rules is a rulebook. [2]
After rules is a rulebook. [3]
Procedural rules is a rulebook. [4]
Accessibility rules is a rulebook. [5]
Action-specific rules is a rulebook. [6]
Carry out rules is a rulebook. [7]
General report rules is a rulebook. [8]
Turn sequence rules is a rulebook. [9]
Reaching inside rules is an object-based-rulebook. [10]
Reaching inside rules have outcomes allow access (success) and deny access
(failure).
Reaching outside rules is an object-based-rulebook. [11]
Reaching outside rules have outcomes allow access (success) and deny access
(failure).
General before rules is a rulebook. [12]
Actor-specific before rules is a rulebook. [13]
Location-specific before rules is a rulebook. [14]
Reaction before rules is a rulebook. [15]
Object-specific before rules is a rulebook. [16]
General after rules is a rulebook. [17]
Actor-specific after rules is a rulebook. [18]
Location-specific after rules is a rulebook. [19]
Reaction after rules is a rulebook. [20]
Object-specific after rules is a rulebook. [21]
When play begins is a rulebook. [22]
When play ends is a rulebook. [23]
Every turn rules is a rulebook. [24]
Check rules is a rulebook. [25]
Report rules is a rulebook. [26]
Persuasion rules is a rulebook. [27]
Persuasion rules have outcomes persuasion succeeds (success) and persuasion
fails (failure).
Unsuccessful attempt by is a rulebook. [28]
Visibility rules is a rulebook. [29]
Visibility rules have outcomes there is sufficient light (failure) and
there is insufficient light (success).
The does the player mean rules are a rulebook. [30] The does the player
mean rules have outcomes it is very likely, it is likely, it is possible,
it is unlikely and it is very unlikely.

Include (-
[ I7_CheckDPMR result;
	if (FollowRulebook( (+does the player mean rules+) ) && RulebookSucceeded()) {
		result = ResultOfRule();
		if (result == (+ it is very likely outcome +) ) return 4;
		if (result == (+ it is likely outcome +) ) return 3;
		if (result == (+ it is possible outcome +) ) return 2;
		if (result == (+ it is unlikely outcome +) ) return 1;
		if (result == (+ it is very unlikely outcome +) ) return 0;
	}
	return 2;
];
-);

[From here on they can be meddled with.]

Scene changing rules is a rulebook.

The little-used do nothing rule corresponds to routine I7_DO_NOTHING.

Section SR2/2 - Advance of time

The advance time rule corresponds to routine TS1_R.
[The timers and daemons rule corresponds to routine TS2_R.
The each turn properties rule corresponds to routine TS3_R.]
The update chronological records rule corresponds to routine TS4_R.
The adjust light rule corresponds to routine TS5_R.
The note object acquisitions rule corresponds to routine TS6_R.
The timed events rule corresponds to routine ProcessI7Timers.
The reset parser disambiguation rule corresponds to routine I7ResetChooseObjects.

The first when play begins rule:
	consider the scene changing rules.

[The first turn sequence rule:
	consider the scene changing rules;
	consider the reset parser disambiguation rule;
	consider the every turn rules;
	consider the timed events rule.]

A first turn sequence rule: consider the every turn rules.
A first turn sequence rule: consider the scene changing rules.
The reset parser disambiguation rule is listed in the turn sequence rulebook.
The timed events rule is listed in the turn sequence rulebook.
The advance time rule is listed in the turn sequence rulebook.

[The timers and daemons rule is listed in the turn sequence rulebook.
The each turn properties rule is listed in the turn sequence rulebook.]

The update chronological records rule is listed in the turn sequence rulebook.
A last turn sequence rule: consider the scene changing rules.
The adjust light rule is listed last in the turn sequence rulebook.
The note object acquisitions rule is listed last in the turn sequence rulebook.

The last scene changing rule:
	run scene change machinery.

The non-player character action rule corresponds to routine I7_NPCA.

The Entire Game is a scene. The Entire Game begins when the game is in progress.
The Entire Game ends when the game is over.

Section SR2/3 - Accessibility of objects

The access to scoped objects rule corresponds to routine OIU_Scoped.
The access through barriers rule corresponds to routine OIU_Barrier.
The can't reach inside closed containers rule corresponds to routine OIUB_CCI.
The can't reach outside closed containers rule corresponds to routine OIUB_CCO.
The can't reach inside rooms rule corresponds to routine OIUB_RI.
The basic accessibility rule corresponds to routine PA_R.
The carrying requirements rule corresponds to routine CR_R.
The can't act in the dark rule corresponds to routine CSITDR.

[The first accessibility rule:
	abide by the access to scoped objects rule.

The last accessibility rule:
	abide by the access through barriers rule.]

The access to scoped objects rule is listed first in the accessibility rules.
The access through barriers rule is listed first in the accessibility rules.

The can't reach inside rooms rule is listed last in the reaching inside rules.
The can't reach inside closed containers rule is listed last in the reaching
inside rules.

[The last reaching inside rule:
	abide by the can't reach inside rooms rule;
	abide by the can't reach inside closed containers rule.]

[The last reaching outside rule:
	abide by the can't reach outside closed containers rule.]

The can't reach outside closed containers rule is listed last in the reaching
outside rules.

[The last visibility rule:
	abide by the can't act in the dark rule.]

The can't act in the dark rule is listed last in the visibility rules.

Does the player mean taking something which is carried by the player (this
is the very unlikely to mean taking what's already carried rule): it is
very unlikely.

Section SR2/4 - Action processing

The last before rule:
	abide by I6 GamePreRoutine;
	abide by I6 orders property;
	abide by I6 location before;
	abide by I6 react_before property;
	abide by I6 object before.

The first after rule:
	abide by I6 GamePostRoutine;
	[I6 does not have actor-specific afters, asymmetrically.]
	abide by I6 location after;
	abide by I6 react_after property;
	abide by I6 object after;
	continue the action.

The first action-processing rule:
	abide by the before rules.

[The last action-processing rule:
	abide by the basic accessibility rule;
	abide by the carrying requirements rule;
	abide by the instead rules;
	abide by the non-player character action rule;
	abide by the action-specific rules;
	rule succeeds.]

The basic accessibility rule is listed in the action-processing rules.
The carrying requirements rule is listed in the action-processing rules.

A last action-processing rule: abide by the instead rules.
A last action-processing rule: abide by the non-player character action rule.
A last action-processing rule: abide by the action-specific rules.
A last action-processing rule: rule succeeds.

[The last before rule:
	abide by the general before rules;
	abide by the actor-specific before rules;
	abide by the location-specific before rules;
	abide by the reaction before rules;
	abide by the object-specific before rules.]

The last action-specific rule:
	cause the action to take place.

[The first after rule:
	abide by the object-specific after rules;
	abide by the reaction after rules;
	abide by the location-specific after rules;
	abide by the actor-specific after rules;
	abide by the general after rules.]


Section SR2/5 - Activity rules

[Activities must not be created until the basic rulebooks are
in place. The order matters too, as these must match constants
defined in the I6 library, so add new ones at the end.]

Printing the name of something (documented at act_pn) is an activity.
Listing contents of something (documented at act_lc) is an activity.
Grouping together something (documented at act_gt) is an activity.
Constructing the status line (documented at act_csl) is an activity.
Listing nondescript items of something (documented at act_lni) is an activity.
Deciding the scope of something (future action) (documented at act_ds) is an activity.
Supplying a missing noun (documented at act_smn) is an activity.
Supplying a missing second noun (documented at act_smn) is an activity.
Reading a command (documented at act_reading) is an activity.
Deciding whether all includes something (future action) (documented at act_all) is an activity.
Printing the player's obituary (documented at act_obit) is an activity.
Amusing a victorious player (documented at act_amuse) is an activity.
Printing the banner text (documented at act_banner) is an activity.
Printing the plural name of something (documented at act_ppn) is an activity.
Deciding the concealed possessions of something (documented at act_con) is an activity.
Printing a refusal to act in the dark (documented at act_toodark) is an activity.
Printing the announcement of darkness (documented at act_nowdark) is an activity.
Printing the name of a dark room (documented at act_darkname) is an activity.
Printing the description of a dark room (documented at act_darkdesc) is an activity.
Printing room description details of something (documented at act_details) is an activity.
Printing a parser error (documented at act_parsererror) is an activity.
Implicitly taking something (documented at act_implicitly) is an activity.
Starting the virtual machine (documented at act_startvm) is an activity.
Clarifying the parser's choice of something (future action) (documented at
act_clarify) is an activity.
Asking which do you mean (future action) (documented at act_which) is an activity.

The last for printing the name rule (this is the standard name printing rule):
	cause the description to take place.
The last for listing contents rule (this is the standard contents listing rule):
	cause the listing to take place.

The print obituary headline rule corresponds to routine OBIT_HEAD.
The print final score rule corresponds to routine OBIT_FINAL.
The display final status line rule corresponds to routine OBIT_DISP.

[The last for printing the player's obituary rule:
	abide by the print obituary headline rule;
	abide by the print final score rule;
	abide by the display final status line rule.]

The print obituary headline rule is listed last in for printing the player's
obituary.
The print final score rule is listed last in for printing the player's
obituary.
The display final status line rule is listed last in for printing the player's
obituary.

Before printing the name of a thing (called the item being printed) (this is the make
named things mentioned rule): now the item being printed is mentioned.

Writing a paragraph about something (documented at act_wpa) is an activity.
Include (- with describe [ o; if (self has (+ mentioned +) ) rtrue; say__p = 0;  
CarryOutActivity( (+ writing a paragraph about +) , self); if (say__p) {
give self (+ mentioned +); rtrue; } ], -) when defining a thing.


Section SR2/6 - Use options

Use American dialect translates as (- Constant DIALECT_US; -).
Use the serial comma translates as (- Constant I7_SERIAL_COMMA; -).
Use full-length room descriptions translates as (- Constant I7_LOOKMODE = 2; -).
Use abbreviated room descriptions translates as (- Constant I7_LOOKMODE = 3; -).
Use memory economy translates as (- Constant I7_ECONOMY; -).
Use no scoring translates as (- Constant I7_NOSCORE; -).
Use command line echoing translates as (- Constant I7_ECHOCOM; -).
Use undo prevention translates as (- Constant PREVENT_UNDO; -).
Use predictable randomisation translates as (- Constant FIX_RNG; -).

Part SR3 - Actions

Section SR3/1 - Generic action patterns

Section SR3/2 - Actions which move things

Taking inventory is an action corresponding to Inv
	anybody
	past participle taken,
	applying to nothing
	- check -
	none
	- carry-out -
	default inventory style rule = InvSub_O1
	print empty inventory rule = InvSub_O2
	print standard inventory rule = InvSub_O3
	use inventory to set pronouns rule = InvSub_O4
	- report -
	report other people taking inventory rule = InvSub_R1.

Taking is an action corresponding to Take
	anybody
	past participle taken
	applying to one thing
	- check -
	avoid unnecessary implicit taking rule = TakeSub_C1
	can't take yourself rule = TakeSub_C2
	can't take other people rule = TakeSub_C3
	can't take component parts rule = OIUB_CP
	determine common ancestor for taking rule = TakeSub_C4
	can't take people's possessions rule = OIUB_AP
	[can't take from distant locations rule = TakeSub_C5]
	can't take what you're inside rule = TakeSub_C6
	can't take what's already taken rule = TakeSub_C7
	check let-go-before rule = TakeSub_C8
	can't take scenery rule = TakeSub_C9
	can't take what's fixed in place rule = TakeSub_C10
	use player's holdall to avoid exceeding carrying capacity rule = TakeSub_C11
	can't exceed carrying capacity rule = TakeSub_C12
	- carry-out -
	standard taking rule = TakeSub_O1
	check let-go-after rule = TakeSub_O2
	- report -
	don't report successful implicit takes rule = TakeSub_R1
	standard report taking rule = TakeSub_R2.

Removing it from is an action corresponding to Remove
	anybody
	applying to two things
	- check -
	can't take component parts rule = qv
	can't remove what's not inside rule = RemoveSub_C2
	can't remove from people rule = RemoveSub_C3
	convert remove to take rule = RemoveSub_C4
	can't remove from closed containers rule = RemoveSub_C1
	can't take yourself rule = qv
	can't take other people rule = qv
	determine common ancestor for taking rule = qv
	can't take people's possessions rule = qv
	[can't take from distant locations rule = qv]
	can't take what you're inside rule = qv
	can't take what's already taken rule = qv
	check let-go-before rule = qv
	can't take scenery rule = qv
	can't take what's fixed in place rule = qv
	use player's holdall to avoid exceeding carrying capacity rule = qv
	can't exceed carrying capacity rule = qv
	- carry-out -
	standard taking rule = qv
	check after-rules for taking too rule = RemoveSub_O2
	- report -
	standard report removing rule = RemoveSub_R1.

Dropping is an action corresponding to Drop
	anybody
	applying to one thing
	- check -
	can't drop yourself rule = DropSub_C1
	can't drop what's already dropped rule = DropSub_C2
	can't drop what's not held rule = DropSub_C3
	can't drop clothes being worn rule = DropSub_C4
	can't drop if this exceeds carrying capacity rule = DropSub_C5
	- carry-out -
	standard dropping rule = DropSub_O1
	- report -
	standard report dropping rule = DropSub_R1;

Putting it on is an action corresponding to PutOn
	anybody
	past participle put
	applying to two things
	- check -
	convert put to drop where possible rule = PutOnSub_C1
	can't put what's not held rule = PutOnSub_C2
	can't put something on itself rule = PutOnSub_C3
	check receive-before for supporter rule = PutOnSub_C4
	can't put onto what's not a supporter rule = PutOnSub_C5
	can't put onto something being carried rule = PutOnSub_C6
	can't put clothes being worn rule = PutOnSub_C7
	can't put if this exceeds carrying capacity rule = PutOnSub_C8
	- carry-out -
	standard putting rule = PutOnSub_O1
	check receive-after for supporter rule = PutOnSub_O2
	- report -
	standard report putting rule = PutOnSub_R1;

Inserting it into is an action corresponding to Insert
	anybody
	applying to two things
	- check -
	convert insert to drop where possible rule = InsertSub_C1
	can't insert what's not held rule = InsertSub_C2
	can't insert something into itself rule = InsertSub_C3
	can't insert component parts rule = OIUB_CP
	check receive-before for container rule = InsertSub_C4
	can't insert into closed containers rule = InsertSub_C5
	can't insert into what's not a container rule = InsertSub_C6
	can't insert clothes being worn rule = InsertSub_C7
	can't insert if this exceeds carrying capacity rule = InsertSub_C8
	- carry-out -
	standard inserting rule = InsertSub_O1
	check receive-after for container rule = InsertSub_O2
	- report -
	standard report inserting rule = InsertSub_R1;


Section SR3/3 - Actions which move the player

Waiting is an action corresponding to Wait
	anybody
	applying to nothing
	- check -
	none
	- carry-out -
	none
	- report -
	standard report waiting rule = WaitSub_R1.

Going is an action corresponding to Go
	anybody
	past participle gone
	applying to one visible thing
	- check -
	set up going rule = GoSub_C1
	check to see if in a vehicle rule = GoSub_C2
	can't travel in what's not a vehicle rule = GoSub_C3
	determine direction property rule = GoSub_C4
	determine map connection rule = GoSub_C5
	print textual map connections rule = GoSub_C6
	consult routine map connections rule = GoSub_C7
	can't go that way rule = GoSub_C8
	can't go through concealed doors rule = GoSub_C9
	can't go through closed doors rule = GoSub_C10
	determine what's through door rule = GoSub_C11
	- carry-out -
	move player and vehicle rule = GoSub_O1
	move floating objects rule = GoSub_O2
	check light in new location rule = GoSub_O3
	- report -
	describe room gone into rule = GoSub_R1;

Entering is an action corresponding to Enter
	anybody
	applying to one thing
	- check -
	convert enter door into go rule = EnterSub_C1
	convert enter compass direction into go rule = EnterSub_C2
	can't enter what's already entered rule = EnterSub_C3
	can't enter what's not enterable rule = EnterSub_C4
	can't enter closed containers rule = EnterSub_C5
	determine common ancestor for entering rule = EnterSub_C6
	can't enter something carried rule = EnterSub_C7
	implicitly pass through other barriers rule = EnterSub_C8
	- carry-out -
	standard entering rule = EnterSub_O1
	- report -
	standard report entering rule = EnterSub_R1
	describe contents entered into rule = EnterSub_R2;

Exiting is an action corresponding to Exit
	anybody
	applying to nothing
	- check -
	convert exit into go out rule = ExitSub_C1
	can't exit when not inside anything rule = ExitSub_C2
	can't exit closed containers rule = ExitSub_C3
	convert exit into get off rule = ExitSub_C4
	- carry-out -
	standard exiting rule = ExitSub_O1
	- report -
	standard report exiting rule = ExitSub_R1
	describe room emerged into rule = ExitSub_R2;

Getting off is an action corresponding to GetOff
	anybody
	past participle got
	applying to one thing
    - check -
    can't get off things rule = GetOffSub_C1
	- carry-out -
	standard getting off rule = GetOffSub_O1
 	- report -
	standard report getting off rule = GetOffSub_R1
	describe room stood up into rule = GetOffSub_R2;


Section SR3/4 - Actions involving sight

Looking is an action corresponding to Look
	anybody
	applying to nothing
	[requiring light]
	- check -
	none
	- carry-out -
	determine visibility ceiling rule = LookSub_O1
	room description heading rule = LookSub_O2
	room description body text rule = LookSub_O3
	room description paragraphs about objects rule = LookSub_O4
	consult LookRoutine entry point rule = LookSub_O5
	check new arrival rule = LookSub_O6
	- report -
	report other people looking rule = LookSub_R1.

Examining is an action corresponding to Examine
	anybody
	applying to one visible thing
	requiring light
	- check -
	none
	- carry-out -
	examine undescribed containers rule = ExamineSub_O1
	examine undescribed devices rule = ExamineSub_O2
	examine undescribed things rule = ExamineSub_O3
	standard examining rule = ExamineSub_O4
	examine described devices rule = ExamineSub_O5
	- report -
	report other people examining rule = ExamineSub_R1.

Looking under is an action corresponding to LookUnder
	anybody
	applying to one visible thing
	requiring light
	- check -
	none
	- carry-out -
	standard looking under rule = LookUnderSub_O1
	- report -
	report other people looking under rule = LookUnderSub_R1.

Searching is an action corresponding to Search
	anybody
	applying to one thing
	requiring light
	- check -
	can't search unless container or supporter rule = SearchSub_C1
	can't search closed opaque containers rule = SearchSub_C2
	- carry-out -
	standard searching rule = SearchSub_O1
	- report -
	standard search containers rule = SearchSub_R1
	standard search supporters rule = SearchSub_R2
	report other people searching rule = SearchSub_R3.

Consulting it about is an action corresponding to Consult
	anybody
	applying to one thing and one topic
	- check -
	none
	- carry-out -
	none
	- report -
	block consulting rule = ConsultSub_C1.


Section SR3/5 - Actions which change the state of things

Locking it with is an action corresponding to Lock
	anybody
	applying to one thing and one carried thing
	- check -
	can't lock without a lock rule = LockSub_C1
	can't lock what's already locked rule = LockSub_C2
	can't lock what's open rule = LockSub_C3
	can't lock without the correct key rule = LockSub_C4
	- carry-out -
	standard locking rule = LockSub_O1
	- report -
	standard report locking rule = LockSub_R1.

Unlocking it with is an action corresponding to Unlock
	anybody
	applying to one thing and one carried thing
	- check -
	can't unlock without a lock rule = UnlockSub_C1
	can't unlock what's already unlocked rule = UnlockSub_C2
	can't unlock without the correct key rule = UnlockSub_C3
	- carry-out -
	standard unlocking rule = UnlockSub_O1
	- report -
	standard report unlocking rule = UnlockSub_R1.

Switching on is an action corresponding to SwitchOn
	anybody
	applying to one thing
	- check -
	can't switch on unless switchable rule = SwitchOnSub_C1
	can't switch on what's already on rule = SwitchOnSub_C2
	- carry-out -
	standard switching on rule = SwitchOnSub_O1
	- report -
	standard report switching on rule = SwitchOnSub_R1.

Switching off is an action corresponding to SwitchOff
	anybody
	applying to one thing
	- check -
	can't switch off unless switchable rule = SwitchOffSub_C1
	can't switch off what's already off rule = SwitchOffSub_C2
	- carry-out -
	standard switching off rule = SwitchOffSub_O1
	- report -
	standard report switching off rule = SwitchOffSub_R1.

Opening is an action corresponding to Open
	anybody
	applying to one thing
	- check -
	can't open unless openable rule = OpenSub_C1
	can't open what's locked rule = OpenSub_C2
	can't open what's already open rule = OpenSub_C3
	- carry-out -
	standard opening rule = OpenSub_O1
	- report -
	reveal any newly visible exterior rule = OpenSub_R1
	standard report opening rule = OpenSub_R2.

Closing is an action corresponding to Close
	anybody
	applying to one thing
	- check -
	can't close unless openable rule = CloseSub_C1
	can't close what's already closed rule = CloseSub_C2
	- carry-out -
	standard closing rule = CloseSub_O1
	- report -
	standard report closing rule = CloseSub_R1.

Wearing is an action corresponding to Wear
	anybody
	past participle worn
	applying to one carried thing
	- check -
	can't wear what's not clothing rule = WearSub_C1
	can't wear what's not held rule = WearSub_C2
	can't wear what's already worn rule = WearSub_C3
	- carry-out -
	standard wearing rule = WearSub_O1
	- report -
	standard report wearing rule = WearSub_R1.

Taking off is an action corresponding to Disrobe
	anybody
	past participle taken
	applying to one carried thing
	- check -
	can't take off what's not worn rule = DisrobeSub_C1
	- carry-out -
	standard taking off rule = DisrobeSub_O1
	- report -
	standard report taking off rule = DisrobeSub_R1.

Eating is an action corresponding to Eat
	anybody
	past participle eaten
	applying to one carried thing
	- check -
	can't eat unless edible rule = EatSub_C1
	can't eat clothing without removing it first rule = EatSub_C2
	- carry-out -
	standard eating rule = EatSub_O1
	- report -
	standard report eating rule = EatSub_R1.


Section SR3/6 - Actions concerning other people

Giving it to is an action corresponding to Give
	anybody
	past participle given
	applying to one carried thing and one thing
	- check -
	can't give what you haven't got rule = GiveSub_C1
	can't give to yourself rule = GiveSub_C2
	can't give to a non-person rule = GiveSub_C3
	check life property for giving rule = GiveSub_C4
	block giving rule = GiveSub_C5
	- carry-out -
	standard giving rule = GiveSub_O1
	- report -
	standard report giving rule = GiveSub_R1.

Showing it to is an action corresponding to Show
	past participle shown
	applying to one carried thing and one visible thing
	- check -
	can't show what you haven't got rule = ShowSub_C1
	convert show to yourself to examine rule = ShowSub_C2
	check life property for showing rule = ShowSub_C3
	block showing rule = ShowSub_C4
	- carry-out -
	none
	- report -
	none.

Waking is an action corresponding to WakeOther
	past participle woken
	applying to one thing
	- check -
	check life property for waking rule = WakeOtherSub_C1
	block waking rule = WakeOtherSub_C2
	- carry-out -
	none
	- report -
	none.

Throwing it at is an action corresponding to ThrowAt
	past participle thrown
	applying to one carried thing and one visible thing
	- check -
	check thrown-at rule = ThrowAtSub_C1
	implicitly remove thrown clothing rule = ThrowAtSub_C2
	futile to throw things at inanimate objects rule = ThrowAtSub_C3
	check life property for throwing at rule = ThrowAtSub_C4
	block throwing at rule = ThrowAtSub_C5
	- carry-out -
	none
	- report -
	none.

Attacking is an action corresponding to Attack
	applying to one thing
	- check -
	check life property for attacking rule = AttackSub_C1
	block attacking rule = AttackSub_C2
	- carry-out -
	none
	- report -
	none.

Kissing is an action corresponding to Kiss
	applying to one thing
	- check -
	kissing yourself rule = KissSub_C1
	check life property for kissing rule = KissSub_C2
	block kissing rule = KissSub_C3
	- carry-out -
	none
	- report -
	none.

Answering it that is an action corresponding to Answer
	applying to one thing and one topic
	- check -
	check life property for answering rule = AnswerSub_C1
	- carry-out -
	none
	- report -
	block answering rule = AnswerSub_C2.

Telling it about is an action corresponding to Tell
	past participle told
	applying to one thing and one topic
	- check -
	telling yourself rule = TellSub_C1
	check life property for telling rule = TellSub_C2
	- carry-out -
	none
	- report -
	block telling rule = TellSub_C3.

Asking it about is an action corresponding to Ask
	applying to one thing and one topic
	- check -
	check life property for asking rule = AskSub_C1
	- carry-out -
	none
	- report -
	block asking rule = AskSub_C2.

Asking it for is an action corresponding to AskFor
	anybody
	applying to two things
	- check -
	asking yourself for something rule = AskForSub_C1
	translate asking for to giving rule = AskForSub_C2
	- carry-out -
	none
	- report -
	none.

Section SR3/7 - Actions which are checked but then do nothing unless rules intervene

Touching is an action corresponding to Touch
	anybody
	applying to one thing
	- check -
	none
	- carry-out -
	none
	- report -
	report touching yourself rule = TouchSub_R1
	report touching other people rule = TouchSub_R2
	report touching things rule = TouchSub_R3.

Waving is an action corresponding to Wave
	anybody
	applying to one thing
	- check -
	can't wave what's not held rule = WaveSub_C1
	- carry-out -
	none
	- report -
	report waving things rule = WaveSub_R1.

Pulling is an action corresponding to Pull
	anybody
	applying to one thing
	- check -
	can't pull what's fixed in place rule = PullSub_C1
	can't pull scenery rule = PullSub_C2
	can't pull people rule = PullSub_C3
	- carry-out -
	none
	- report -
	report pulling rule = PullSub_R1.

Pushing is an action corresponding to Push
	anybody
	applying to one thing
	- check -
	can't push what's fixed in place rule = PushSub_C1
	can't push scenery rule = PushSub_C2
	can't push people rule = PushSub_C3
	- carry-out -
	none
	- report -
	report pushing rule = PushSub_R1.

Turning is an action corresponding to Turn
	anybody
	applying to one thing
	- check -
	can't turn what's fixed in place rule = TurnSub_C1
	can't turn scenery rule = TurnSub_C2
	can't turn people rule = TurnSub_C3
	- carry-out -
	none
	- report -
	report turning rule = TurnSub_R1.

Pushing it to is an action corresponding to PushDir
	anybody
	applying to two things
	- check -
	block pushing in directions rule = PushDirSub_C1
	- carry-out -
	none
	- report -
	none.

Squeezing is an action corresponding to Squeeze
	anybody
	applying to one thing
	- check -
	innuendo about squeezing people rule = SqueezeSub_C1
	- carry-out -
	none
	- report -
	report squeezing rule = SqueezeSub_R1.


Section SR3/8 - Actions which always do nothing unless rules intervene

Saying yes is an action corresponding to Yes
	past participle said
	applying to nothing
	- check -
	block saying yes rule = YesSub_C1
	- carry-out -
	none
	- report -
	none.

Saying no is an action corresponding to No
	past participle said
	applying to nothing
	- check -
	block saying no rule = NoSub_C1
	- carry-out -
	none
	- report -
	none.

Burning is an action corresponding to Burn
	applying to one thing
	- check -
	block burning rule = BurnSub_C1
	- carry-out -
	none
	- report -
	none.

[Praying is an action corresponding to Pray
	applying to nothing
	- check -
	block praying rule = PraySub_C1
	- carry-out -
	none
	- report -
	none.]

Waking up is an action corresponding to Wake
	past participle woken
	applying to nothing
	- check -
	block waking up rule = WakeSub_C1
	- carry-out -
	none
	- report -
	none.

Thinking is an action corresponding to Think
	past participle thought
	applying to nothing
	- check -
	block thinking rule = ThinkSub_C1
	- carry-out -
	none
	- report -
	none.

Smelling is an action corresponding to Smell
	applying to one thing
	- check -
	block smelling rule = SmellSub_C1
	- carry-out -
	none
	- report -
	none.

Listening to is an action corresponding to Listen
	applying to one thing
	- check -
	block listening rule = ListenSub_C1
	- carry-out -
	none
	- report -
	none.

Tasting is an action corresponding to Taste
	applying to one thing
	- check -
	block tasting rule = TasteSub_C1
	- carry-out -
	none
	- report -
	none.

[Digging is an action corresponding to Dig
	past participle dug
	applying to one thing
	- check -
	block digging rule = DigSub_C1
	- carry-out -
	none
	- report -
	none.]

Cutting is an action corresponding to Cut
	past participle cut
	applying to one thing
	- check -
	block cutting rule = CutSub_C1
	- carry-out -
	none
	- report -
	none.

Jumping is an action corresponding to Jump
	applying to nothing
	- check -
	block jumping rule = JumpSub_C1
	- carry-out -
	none
	- report -
	none.

[Jumping over is an action corresponding to JumpOver
	applying to one thing
	- check -
	block jumping over rule = JumpOverSub_C1
	- carry-out -
	none
	- report -
	none.]

Tying it to is an action corresponding to Tie
	past participle tied
	applying to two things
	- check -
	block tying rule = TieSub_C1
	- carry-out -
	none
	- report -
	none.

Drinking is an action corresponding to Drink
	past participle drunk
	applying to one thing
	- check -
	block drinking rule = DrinkSub_C1
	- carry-out -
	none
	- report -
	none.

[Filling is an action corresponding to Fill
	applying to one thing
	- check -
	block filling rule = FillSub_C1
	- carry-out -
	none
	- report -
	none.]

Saying sorry is an action corresponding to Sorry
	past participle said
	applying to nothing
	- check -
	block saying sorry rule = SorrySub_C1
	- carry-out -
	none
	- report -
	none.

Swearing obscenely is an action corresponding to Strong
	censored
	past participle sworn
	applying to nothing
	- check -
	block swearing obscenely rule = StrongSub_C1
	- carry-out -
	none
	- report -
	none.

Swearing mildly is an action corresponding to Mild
	censored
	past participle sworn
	applying to nothing
	- check -
	block swearing mildly rule = MildSub_C1
	- carry-out -
	none
	- report -
	none.

[Swimming is an action corresponding to Swim
	past participle swum
	applying to nothing
	- check -
	block swimming rule = SwimSub_C1
	- carry-out -
	none
	- report -
	none.]

Swinging is an action corresponding to Swing
	past participle swung
	applying to one thing
	- check -
	block swinging rule = SwingSub_C1
	- carry-out -
	none
	- report -
	none.

[Blowing is an action corresponding to Blow
	past participle blown
	applying to one thing
	- check -
	block blowing rule = BlowSub_C1
	- carry-out -
	none
	- report -
	none.]

Rubbing is an action corresponding to Rub
	applying to one thing
	- check -
	block rubbing rule = RubSub_C1
	- carry-out -
	none
	- report -
	none.

Setting it to is an action corresponding to SetTo
	past participle set
	applying to one thing and one topic
	- check -
	block setting to rule = SetToSub_C1
	- carry-out -
	none
	- report -
	none.

Waving hands is an action corresponding to WaveHands
	applying to nothing
	- check -
	block waving hands rule = WaveHandsSub_C1
	- carry-out -
	none
	- report -
	none.

Buying is an action corresponding to Buy
	past participle bought
	applying to one thing
	- check -
	block buying rule = BuySub_C1
	- carry-out -
	none
	- report -
	none.

Singing is an action corresponding to Sing
	past participle sung
	applying to nothing
	- check -
	block singing rule = SingSub_C1
	- carry-out -
	none
	- report -
	none.

Climbing is an action corresponding to Climb
	applying to one thing
	- check -
	block climbing rule = ClimbSub_C1
	- carry-out -
	none
	- report -
	none.

Sleeping is an action corresponding to Sleep
	past participle slept
	applying to nothing
	- check -
	block sleeping rule = SleepSub_C1
	- carry-out -
	none
	- report -
	none.


Section SR3/9 - Actions which happen out of world

Requesting the score is an action corresponding to Score
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	announce the score rule = ScoreSub_O1
	- report -
	none.

Quitting the game is an action corresponding to Quit
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	quit the game rule = QuitSub_O1
	- report -
	none.

Saving the game is an action corresponding to Save
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	save the game rule = SaveSub_O1
	- report -
	none.

Restoring the game is an action corresponding to Restore
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	restore the game rule = RestoreSub_O1
	- report -
	none.

Restarting the game is an action corresponding to Restart
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	restart the game rule = RestartSub_O1
	- report -
	none.

Verifying the story file is an action corresponding to Verify
	out of world
	past participle verified
	applying to nothing
	- check -
	none
	- carry-out -
	verify the story file rule = VerifySub_O1
	- report -
	none.

Requesting the story file version is an action corresponding to Version
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	announce the story file version rule = VersionSub_O1
	- report -
	none.

Switching the story transcript on is an action corresponding to ScriptOn
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	switch the story transcript on rule = ScriptOnSub_O1
	- report -
	none.

Switching the story transcript off is an action corresponding to ScriptOff
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	switch the story transcript off rule = ScriptOffSub_O1
	- report -
	none.

Preferring abbreviated room descriptions is an action corresponding to LMode3
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	prefer abbreviated room descriptions rule = LMode3Sub_O1
	- report -
	none.

Preferring unabbreviated room descriptions is an action corresponding to LMode2
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	prefer unabbreviated room descriptions rule = LMode2Sub_O1
	- report -
	none.

Preferring sometimes abbreviated room descriptions is an action corresponding to LMode1
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	prefer sometimes abbreviated room descriptions rule = LMode1Sub_O1
	- report -
	none.

Requesting the pronoun meanings is an action corresponding to Pronouns
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	announce the pronoun meanings rule = PronounsSub_O1
	- report -
	none.

Switching score notification on is an action corresponding to NotifyOn
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	switch score notification on rule = NotifyOnSub_O1
	- report -
	none.

Switching score notification off is an action corresponding to NotifyOff
	out of world
	applying to nothing
	- check -
	none
	- carry-out -
	switch score notification off rule = NotifyOffSub_O1
	- report -
	none.

Section SR3/9 - Grammar

Understand "take [things]" as taking.
Understand "take off [something]" as taking off.
Understand "take [things inside] from [something]" as removing it from.
Understand "take [things inside] off [something]" as removing it from.
Understand "take inventory" as taking inventory.
Understand the commands "carry" and "hold" as "take".

Understand "get out/off/up" as exiting.
Understand "get [things]" as taking.
Understand "get in/into/on/onto [something]" as entering.
Understand "get off [something]" as getting off.
Understand "get [things inside] from [something]" as removing it from.

Understand "pick up [things]" or "pick [things] up" as taking.

Understand "stand" or "stand up" as exiting.
Understand "stand on [something]" as entering.

Understand "remove [something preferably held]" as taking off.
[Understand "remove [things]" as taking.]
Understand "remove [things inside] from [something]" as removing it from.

Understand "shed [something preferably held]" as taking off.
Understand the commands "doff" and "disrobe" as "shed".

Understand "wear [something preferably held]" as wearing.
Understand the command "don" as "wear".

Understand "put [other things] in/inside/into [something]" as inserting it into.
Understand "put [other things] on/onto [something]" as putting it on.
Understand "put on [something preferably held]" as wearing.
Understand "put down [things preferably held]" or "put [things preferably held]
down" as dropping.

Understand "insert [other things] in/into [something]" as inserting it into.

Understand "drop [things preferably held]" as dropping.
Understand "drop [other things] in/into/down [something]" as inserting it into.
Understand "drop [other things] on/onto [something]" as putting it on.
Understand "drop [something preferably held] at/against/on/onto [something]"
as throwing it at.
Understand the commands "throw" and "discard" as "drop".

Understand "give [something preferably held] to [someone]" as giving it to.
Understand "give [someone] [something preferably held]" as giving it to (with nouns reversed).
Understand the commands "pay" and "offer" and "feed" as "give".

Understand "show [someone] [something preferably held]" as showing it to (with nouns reversed).
Understand "show [something preferably held] to [someone]" as showing it to.
Understand the commands "present" and "display" as "show".

Understand "go" as going.
Understand "go [direction]" as going.
Understand "go [something]" as entering.
Understand "go into/in/inside/through [something]" as entering.
Understand the commands "walk", "leave" and "run" as "go".

Understand "inventory" as taking inventory.
Understand the commands "i" and "inv" as "inventory".

Understand "look" as looking.
Understand "look at [something]" as examining.
Understand "look inside/in/into/through [something]" as searching.
Understand "look under [something]" as looking under.
Understand "look up [text] in [something]" as consulting it about (with nouns reversed).
Understand the command "l" as "look".

Understand "consult [something] on/about [text]" as consulting it about.

Understand "open [something]" as opening.
Understand "open [something] with [something preferably held]" as unlocking it with.
Understand the commands "unwrap", "uncover" as "open".

Understand "close [something]" as closing.
Understand "close up [something]" as closing.
Understand "close off [something]" as switching off.
Understand the commands "shut" and "cover" as "close".

Understand "enter [something]" as entering.
Understand the command "cross" as "enter".

Understand "sit on top of [something]" as entering.
Understand "sit on/in/inside [something]" as entering.

Understand "exit" as exiting.
Understand the command "out" as "exit".

Understand "examine [something]" as examining.
Understand the commands "x", "watch", "describe" and "check" as "examine".

Understand "read [something]" as examining.
Understand "read about [text] in [something]" as consulting it about (with nouns reversed).
Understand "read [text] in [something]" as consulting it about (with nouns reversed).

Understand "yes" as saying yes.
Understand the command "y" as "yes".

Understand "no" as saying no.

Understand "sorry" as saying sorry.

Understand "shit" as swearing obscenely.
Understand the commands "fuck" and "damn" as "shit".

Understand "bother" as swearing mildly.
Understand the commands "curses", "drat" and "darn" as "bother".

Understand "search [something]" as searching.

Understand "wave" as waving hands.

Understand "wave [something]" as waving.

Understand "set [something] to [text]" as setting it to.
Understand the command "adjust" as "set".

Understand "pull [something]" as pulling.
Understand the command "drag" as "pull".

Understand "push [something]" as pushing.
Understand "push [something] [direction]" or "push [something]
to [direction]" as pushing it to.
Understand the commands "move", "shift", "clear" and "press" as "push".

Understand "turn [something]" as turning.
Understand "turn [something] on" or "turn on [something]" as switching on.
Understand "turn [something] off" or "turn off [something]" as switching off.
Understand the commands "rotate", "twist", "unscrew" and "screw" as "turn".

Understand "switch [something]" or "switch [something] on" as switching on.
Understand "switch [something] off" or "switch off [something]" as switching off.

Understand "lock [something] with [something preferably held]" as locking it with.

Understand "unlock [something] with [something preferably held]" as unlocking it with.

Understand "attack [something]" as attacking.
Understand the commands "break", "smash", "hit", "fight", "torture", "wreck",
"crack", "destroy", "murder", "kill", "punch" and "thump" as "attack".

Understand "wait" as waiting.
Understand the command "z" as "wait".

Understand "answer [text] to [someone]" as answering it that (with nouns reversed).
Understand the commands "say", "shout" and "speak" as "answer".

Understand "tell [someone] about [text]" as telling it about.

Understand "ask [someone] about [text]" as asking it about.
Understand "ask [someone] for [something]" as asking it for.

Understand "eat [something preferably held]" as eating.

Understand "sleep" as sleeping.
Understand the command "nap" as "sleep".

Understand "sing" as singing.

Understand "climb [something]" or "climb up/over [something]" as climbing.
Understand the command "scale" as "climb".

Understand "buy [something]" as buying.
Understand the command "purchase" as "buy".

Understand "squeeze [something]" as squeezing.
Understand the command "squash" as "squeeze".

[Understand "swim" as swimming.
Understand the command "dive" as "swim".]

Understand "swing [something]" or "swing on [something]" as swinging.

[Understand "blow [something preferably held]" as blowing.]

[Understand "pray" as praying.]

Understand "wake" or "wake up" as waking up.
Understand "wake [someone]" or "wake [someone] up" or "wake up [someone]"
as waking.
Understand the commands "awake" and "awaken" as "wake".

Understand "kiss [someone]" as kissing.
Understand the commands "embrace" and "hug" as "kiss".

Understand "think" as thinking.

Understand "smell" as smelling.
Understand "smell [something]" as smelling.
Understand the command "sniff" as "smell".

Understand "listen" as listening.
Understand "hear [something]" as listening.
Understand "listen to [something]" as listening.

Rule for supplying a missing noun while smelling (this is the ambient
odour rule): change the noun to the location. Rule for supplying a
missing noun while listening (this is the ambient sound rule): change
the noun to the location. Rule for supplying a missing noun while
going (this is the block vaguely going rule): say "You'll have to say
which compass direction to go in."

Understand "taste [something]" as tasting.

Understand "touch [something]" as touching.
Understand the command "feel" as "touch".

Understand "rub [something]" as rubbing.
Understand the commands "shine", "polish", "sweep", "clean", "dust", "wipe"
and "scrub" as "rub".

Understand "tie [something] to [something]" as tying it to.
Understand the commands "attach", "fix" and "fasten" as "tie".

Understand "burn [something]" as burning.
Understand the command "light" as "burn".

Understand "drink [something]" as drinking.
Understand the commands "swallow" and "sip" as "drink".

[Understand "fill [something]" as filling.]

Understand "cut [something]" as cutting.
Understand the commands "slice", "prune" and "chop" as "cut".

Understand "jump" as jumping.
[Understand "jump over [something]" as jumping over.]
Understand the commands "skip" and "hop" as "jump".

[Understand "dig [something]" as digging.]

Understand "score" as requesting the score.
[Understand "full score" or "fullscore" as requesting the full score.]
Understand "quit" or "q" as quitting the game.
Understand "save" as saving the game.
Understand "restart" as restarting the game.
Understand "restore" as restoring the game.
Understand "verify" as verifying the story file.
Understand "version" as requesting the story file version.
Understand "script" or "script on" or "transcript" or "transcript on"
	as switching the story transcript on.
Understand "script off" or "transcript off" as switching the story transcript off.
Understand "superbrief" or "short" as preferring abbreviated room descriptions.
Understand "verbose" or "long" as preferring unabbreviated room descriptions.
Understand "brief" or "normal" as preferring sometimes abbreviated room descriptions.
Understand "nouns" or "pronouns" as requesting the pronoun meanings.
Understand "notify" or "notify on" as switching score notification on.
Understand "notify off" as switching score notification off.

Part SR4 - Phrasebook

Section SR4/0 - Saying

To say (something - string-of-text)
	(documented at ph_say):
	(- print (I7_string) {something}; -).
To say (something - text-routine):
	(- print (I7_string) {something}; -).
To say (something - number):
	(- print (say__n={something}); -).
To say s: (- I7_say_s(); -).
To say (something - time):
	(- print (PrintTimeOfDay) {something}; -).
To say (something - time) in words:
	(- print (PrintTimeOfDayEnglish) {something}; -).
To say (something - unicode-character) -- running on:
	(- #ifdef TARGET_ZCODE; @print_unicode {something};
		#ifnot; glk_put_char_uni({something}); #endif; -).
To say (something - snippet):
	(- print (PrintSnippet) {something}; -).
To say (something - number) in words:
	(- print (number) say__n={something}; -).
To say the (something - number) in words:
	(- print (number) say__n={something}; -).
To say (something - object):
	(- print (name) {something}; -).
To say a (something - object):
	(- print (a) {something}; -).
To say an (something - object):
	(- print (a) {something}; -).
To say A (something - object):
	(- CIndefArt({something}); -).
To say An (something - object):
	(- CIndefArt({something}); -).
To say the (something - object):
	(- print (the) {something}; -).
To say The (something - object):
	(- print (The) {something}; -).
To say (something - table-name):
	(- print (PrintTableName) {something}; -).
To say (something - rule):
	(- I7_RulePrintingRule({something}); -).
To say (something - rulebook-outcome):
	(- I7_RulebookOutcomePrintingRule({something}); -).
To say the player's surroundings
	(documented at ph_surrounds):
	(- SL_Location(); -).
To say list of extension credits:
	(- I7ExtensionVersions(); -).
To say banner text:
	(- Banner(); -).
To say if (c - condition)
	(documented at ph_sayif):
	(- {-erase} 
.{-label:Say}; if ({c}) say__c=true; else jump {-next-label:Say}; -).
To say end if:
	(- {-erase} 
.{-label:Say}; say__c = false; -).
To say otherwise:
	(- {-erase}
.{-label:Say}; if (say__c==false) say__c=true; else jump {-next-label:Say}; -).
To say otherwise if (c - condition):
	(-
.{-label:Say}; if (say__c==false) { say__c=(({c})==true);
		if (say__c==false) jump {-next-label:Say};
	} else jump {-next-label:Say};
-).
To say line break -- running on:
	(- new_line; -).
To say no line break -- running on: do nothing.
To say conditional paragraph break -- running on:
	(- I7_DivideParagraph(); -).
To say command clarification break -- running on:
	(- I7_CommandClarificationBreak(); -).
To say paragraph break -- running on:
	(- I7_DivideParagraph(); new_line; -).
To say run paragraph on -- running on:
	(- I7_RunOnParagraph(true); -).
To say bracket -- running on:
	(- print "["; -).
To say close bracket -- running on:
	(- print "]"; -).
To say apostrophe/' -- running on:
	(- print "'"; -).
To say quotation mark -- running on:
	(- print "~"; -).
To display (F - figure-name), one time only:
	(- print "^"; I7_DisplayFigure({F}, {phrase options}); print "^"; -).

Section SR4/1 - The score and the outcome

To change the player to (O - an object):
	(- I7_ChangePlayer({O}); -).
To award (some - number) point:
	(- score=score+{some}; -).
To award (some - number) points:
	(- score=score+{some}; -).
To end the game in death
	(documented at ph_end):
	(- deadflag=1; -).
To end the game in victory:
	(- deadflag=2; -).
To end the game saying (finale - text):
	(- deadflag={finale}; -).
To resume the game:
	(- deadflag=0; -).
To decide whether the game is in progress: (- (deadflag==0) -).
To decide whether the game is over: (- (deadflag~=0) -).
To decide whether the game ended in death: (- (deadflag==1) -).
To decide whether the game ended in victory: (- (deadflag==2) -).

Section SR4/2 - Actions and activities

To try (doing something - action)
	(documented at ph_try):
	(- {doing something}; -).
To silently try (doing something - action):
	(- @push keep_silent; keep_silent=1; {doing something}; @pull keep_silent; -).
To try silently (doing something - action):
	(- @push keep_silent; keep_silent=1; {doing something}; @pull keep_silent; -).

To decide whether the action requires a touchable noun: 
    (- (I7_NeedToTouchNoun()) -).
To decide whether the action requires a touchable second noun: 
    (- (I7_NeedToTouchSecondNoun()) -).
To decide whether the action requires a carried noun: 
    (- (I7_NeedToCarryNoun()) -).
To decide whether the action requires a carried second noun: 
    (- (I7_NeedToCarrySecondNoun()) -).
To decide whether the action requires light: 
    (- (I7_NeedLightForAction()) -).

To stop the action
	(documented at ph_stop):
	(- rtrue; -) - outcome.
To continue the action:
	(- rfalse; -) - outcome.
To continue the activity:
	(- rfalse; -).

To carry out the (A - activity) activity
	(documented at ph_carryout):
	(- CarryOutActivity({A}); -).
To begin the (A - activity) activity:
	(- BeginActivity({A}); -).
To decide whether handling (A - activity) activity:
	(- (~~(ForActivity({A}))) -).
To end the (A - activity) activity:
	(- EndActivity({A}); -).
To carry out the (A - activity) activity with (O - object):
	(- CarryOutActivity({A}, {O}); -).
To begin the (A - activity) activity with (O - object):
	(- BeginActivity({A}, {O}); -).
To decide whether handling (A - activity) activity with (O - object):
	(- (~~(ForActivity({A}, {O}))) -).
To end the (A - activity) activity with (O - object):
	(- EndActivity({A}, {O}); -).
To decide whether (A - activity) activity is going on:
	(- (TestActivity({A})) -).

To do nothing (documented at ph_nothing):
	(- ; -).
To it does:
	(- RulebookSucceeds(); rtrue; -).
To it does not:
	(- RulebookFails(); rtrue; -).

Section SR4/3 - Moving and removing things

To remove (something - object) from play
	(documented at ph_remove):
	(- I7_Remove({something}); -).
To move (something - object) to (something else - object),
	without printing a room description
	or printing an abbreviated room description
	(documented at ph_move):
	(- I7_Move({something}, {something else}, {phrase options}, {phrase line}); -).

To decide which object is holder of (something - object)
	(documented at ph_holder):
	(- (I7_Holder({something})) -).
To decide which object is next thing held after (something - object):
	(- (sibling({something})) -).
To decide which object is first thing held by (something - object):
	(- (child({something})) -).

To decide whether in (somewhere - an object):
	(- (I7_WhetherIn({somewhere})) -).
To decide whether in darkness:
	(- (location==thedark) -).

To decide which object is best route from (R1 - object) to (R2 - object),
	using doors or using even locked doors:
	(- I7_RouteTo({R1},{R2},0,{phrase options}) -).
To decide which number is number of moves from (R1 - object) to (R2 - object),
	using doors or using even locked doors:
	(- I7_CountRouteTo({R1},{R2},0,{phrase options}) -).
To decide which object is best route from (R1 - object) to (R2 - object) through
	(RS - [specification] description),
	using doors or using even locked doors:
	(- I7_RouteTo({R1},{R2},{RS},{phrase options}) -).
To decide which number is number of moves from (R1 - object) to (R2 - object) through
	(RS - [specification] description),
	using doors or using even locked doors:
	(- I7_CountRouteTo({R1},{R2},{RS},{phrase options}) -).
To decide which room is room (D - direction) from (R1 - room):
	(- I7_RoomFrom({R1},{D},2) -).
To change (D - direction) exit of (R1 - room) to (R2 - room):
	(- I7_ChangeExit({R1},{D},{R2}); -).
To decide which object is next step via (R - abstract-relation)
	from (O1 - object) to (O2 - object):
	(- I7_RelRouteTo({R},{O1},{O2}) -).
To decide which number is number of steps via (R - abstract-relation)
	from (O1 - object) to (O2 - object):
	(- I7_CountRelRouteTo({R},{O1},{O2}) -).
To decide which room is the front side of (D - object):
	(- I7_FrontSide({D}) -).
To decide which room is the back side of (D - object):
	(- I7_BackSide({D}) -).
To decide which room is location of (O - object):
	(- I7_Location({O}) -).


Section SR4/4 - Arithmetic

To decide which number is number of (S - [specification] description):
	(- {-number-of:S} -).
To decide which number is (X - number) + (Y - number)
	(arithmetic operation 0)
	(documented at ph_plus): (- ({X}+{Y}) -).
To decide which number is (X - number) - (Y - number)
	(arithmetic operation 1):
	(- ({X}-{Y}) -).
To decide which number is (X - number) * (Y - number)
	(arithmetic operation 2):
	(- ({X}*{Y}) -).
To decide which number is (X - number) / (Y - number)
	(arithmetic operation 3):
	(- (I7_Divide({X},{Y})) -).
To decide which number is (X - number) plus (Y - number)
	(arithmetic operation 0):
	(- ({X}+{Y}) -).
To decide which number is (X - number) minus (Y - number)
	(arithmetic operation 1):
	(- ({X}-{Y}) -).
To decide which number is (X - number) times (Y - number)
	(arithmetic operation 2):
	(- ({X}*{Y}) -).
To decide which number is (X - number) multiplied by (Y - number)
	(arithmetic operation 2):
	(- ({X}*{Y}) -).
To decide which number is (X - number) divided by (Y - number)
	(arithmetic operation 3):
	(- (I7_Divide({X},{Y})) -).
To decide which number is remainder after dividing (X - number)
	by (Y - number)
	(arithmetic operation 4):
	(- (I7_Rem({X},{Y})) -).
To decide which number is total (p - property) of (S - [specification] description)
	(arithmetic operation 5):
	(- {-total-of:S} -).


Section SR4/5 - Time

To decide which time is (t - time) to the nearest (t2 - time)
	(documented at ph_nearest):
	(- (RoundOffTime({t},{t2})) -).
To decide which number is the minutes part of (t - time)
	(documented at ph_minspart):
	(- ({t}%60) -).
To decide which number is the hours part of (t - time):
	(- ({t}/60) -).
To decide if (t - time) is before (t2 - time):
	(- ((({t}+20*60)%(60*24))<(({t2}+20*60)%(60*24))) -).
To decide if (t - time) is after (t2 - time):
	(- ((({t}+20*60)%(60*24))>(({t2}+20*60)%(60*24))) -).
To decide if it is before (t2 - time):
	(- (((the_time+20*60)%(60*24))<(({t2}+20*60)%(60*24))) -).
To decide if it is after (t2 - time):
	(- (((the_time+20*60)%(60*24))>(({t2}+20*60)%(60*24))) -).
To decide which time is (t - time) before (t2 - time)
	(documented at ph_timeshift):
	(- (({t2}-{t}+60*24)%(60*24)) -).
To decide which time is (t - time) after (t2 - time):
	(- (({t2}+{t}+60*24)%(60*24)) -).
To decide which time is (n - number) minutes:
	(- (({n})%(60*24)) -).
To decide which time is (n - number) hours:
	(- (({n}*60)%(60*24)) -).
To (R - rule) in (t - number) turn from now
	(documented at ph_future):
	(- SetI7Timer({R}, {t}+1, 0); -).
To (R - rule) in (t - number) turns from now:
	(- SetI7Timer({R}, {t}+1, 0); -).
To (R - rule) at (t - time):
	(- SetI7Timer({R}, {t}, 1); -).
To (R - rule) in (t - time) from now:
	(- SetI7Timer({R}, (the_time+{t})%(60*24), 1); -).
To decide if (sc - scene) is happening
	(documented at ph_happening):
	(- (scene_status-->({sc}-1)) -).
To decide if (sc - scene) is not happening:
	(- (scene_status-->({sc}-1) == 0) -).
To decide if (sc - scene) has happened:
	(- (scene_endings-->({sc}-1)) -).
To decide if (sc - scene) has not happened:
	(- (scene_endings-->({sc}-1) == 0) -).
To decide if (sc - scene) has ended:
	(- (scene_endings-->({sc}-1) > 1) -).
To decide if (sc - scene) has not ended:
	(- (scene_endings-->({sc}-1) <= 1) -).
To decide which time is the time since (sc - scene) began
	(documented at ph_tsince):
	(- ((the_time - scene_started-->({sc}-1))%(60*24)) -).
To decide which time is the time when (sc - scene) began:
	(- (scene_started-->({sc}-1)) -).
To decide which time is the time since (sc - scene) ended:
	(- ((the_time - scene_ended-->({sc}-1))%(60*24)) -).
To decide which time is the time when (sc - scene) ended:
	(- (scene_ended-->({sc}-1)) -).


Section SR4/6 - Randomness

To decide which object is a random (S - [specification] description):
	(- {-random-of:S} -).
To decide which object is random (S - [specification] description):
	(- {-random-of:S} -).
To decide which number is a random number from (N - number) to (M - number)
	(documented at ph_random):
	(- (random(({M})-({N})+1)+({N})-1) -).
To decide which number is a random number between (N - number) and (M - number):
	(- (random(({M})-({N})+1)+({N})-1) -).
To decide whether a random chance of (N - number) in (M - number) succeeds:
	(- (random({M}) <= {N}) -).
To seed the random-number generator with (N - number):
	(- I7_SeedRNG({N}); -).


Section SR4/7 - Tables

To decide which number is number of rows in (T - table-name)
	(documented at ph_numrows):
	(- TableRows({T}) -).
To decide which number is number of blank rows in (T - table-name)
	(documented at ph_numblank):
	(- TableBlankRows({T}) -).
To decide which number is number of filled rows in (T - table-name):
	(- TableFilledRows({T}) -).
To decide if there is (TR - table-reference)
	(documented at ph_thereis):
	(- (Exists{TR}) -).
To decide if there is no (TR - table-reference):
	(- (Exists{TR} == false) -).
To change (tr - table-reference) to (w - value):
	(- {tr}{-delete},1,{w}); -).
To delete (tr - table-reference)
	(documented at ph_blankout):
	(- {tr}{-delete},1,I7_TABLE_NOVALUE); -).
To blank out the whole row
	(documented at ph_blankout):
	(- {-require-ctvs}TableBlankOutRow(ct_0, ct_1); -).
To choose row (N - number) in (T - table-name)
	(documented at ph_chooserow):
	(- {-require-ctvs}ct_0 = {T}; ct_1 = {N}; -).
To choose the/-- row with (TC - table-column) of (w - value) in (T - table-name):
	(- {-require-ctvs}ct_0 = {T}; ct_1 = TableRowCorr(ct_0, {TC}, {w}); -).
To choose a blank row in (T - table-name):
	(- {-require-ctvs}ct_0 = {T}; ct_1 = TableBlankRow(ct_0); -).
To choose a random row in (T - table-name):
	(- {-require-ctvs}ct_0 = {T}; ct_1 = TableRandomRow(ct_0); -).

Section SR4/7 - Searching and sorting tables

To repeat through (T - table-name) begin -- end
	(documented at ph_tabrepeat):
	(- {-require-ctvs}ct_0 = {T}; for (ct_1=1:ct_1<=TableRows(ct_0):ct_1++) if (TableRowIsBlank(ct_0,ct_1)==false)  -).
To repeat through (T - table-name) in reverse order begin -- end:
	(- {-require-ctvs}ct_0 = {T}; for (ct_1=TableRows(ct_0):ct_1>=1:ct_1-- ) if (TableRowIsBlank(ct_0,ct_1)==false)  -).
To repeat through (T - table-name) in (TC - table-column) order begin -- end:
	(- {-require-ctvs}ct_0 = {T}; for (ct_1=TableNextRow(ct_0,{TC},0,1):ct_1~=0:ct_1=TableNextRow(ct_0,{TC},ct_1,1))  -).
To repeat through (T - table-name) in reverse (TC - table-column) order begin -- end:
	(- {-require-ctvs}ct_0 = {T}; for (ct_1=TableNextRow(ct_0,{TC},0,-1):ct_1~=0:ct_1=TableNextRow(ct_0,{TC},ct_1,-1))  -).
To sort (T - table-name) in random order
	(documented at ph_sort):
    (- TableShuffle({T}); -).
To sort (T - table-name) in (TC - table-column) order:
	(- TableSort({T}, {TC}, 1); -).
To sort (T - table-name) in reverse (TC - table-column) order:
	(- TableSort({T}, {TC}, -1); -).


Section SR4/8 - Changing properties and variables

To let (t - nonexisting variable) be (u - value):
	(- {t} = {u}; -).
To let (t - existing variable) be (u - value):
	(- {t} = {u}; -).

To change (p - property) to (w - value)
	(documented at ph_changev):
	(- Write{p}{-delete},{w}); -).
To change (gv - global variable) to (w - value)
	(documented at ph_change):
	(- {gv} = {w}; -).
To change (lv - existing variable) to (w - value):
	(- {lv} = {w}; -).
To increase/increment (p - property) by (w - value):
	(- Write{p}{-delete},{p}+{w}); -).
To increase/increment (gv - global variable) by (w - value):
	(- {gv} = {gv} + {w}; -).
To increase/increment (lv - existing variable) by (w - value):
	(- {lv} = {lv} + {w}; -).
To increase/increment (tr - table-reference) by (w - value):
	(- {tr}{-delete},2,{w}); -).
To decrease/decrement (p - property) by (w - value):
	(- Write{p}{-delete},{p}-{w}); -).
To decrease/decrement (gv - global variable) by (w - value):
	(- {gv} = {gv} - {w}; -).
To decrease/decrement (lv - existing variable) by (w - value):
	(- {lv} = {lv} - {w}; -).
To decrease/decrement (tr - table-reference) by (w - value):
	(- {tr}{-delete},3,{w}); -).
To change (o - object) to (p - property)
	(documented at ph_changep):
	(- I7SetEitherOr({o}, {p}); -).
To change (o - object) to (w - value):
	(- WriteAccessProp({o},{-convert-adjectival-constants:w},{w}); -).
[To decide if (o - object) has a/an (p - property):
	(- (I7_Provides({o}, {-aorp:p})) -).]
To decide if (o - object) provides the property (p - property):
	(- (I7_Provides({o}, {-aorp:p})) -).
To now (cn - now-condition):
	(- {cn} -).


Section SR4/9 - Listing things in a given place

To list the contents of (O - an object),
	with newlines,
	indented,
	giving inventory information,
	as a sentence,
	including contents,
	including all contents, 
	tersely,
	giving brief inventory information,
	using the definite article,
	listing marked items only,
	prefacing with is/are,
	not listing concealed items,
	suppressing all articles
	and/or with extra indentation
	(documented at ph_list):
	(- I7WriteListFrom(child({O}), {phrase options}); -).
To say contents of (O - an object):
	list the contents of O, as a sentence.
To say the contents of (O - an object):
	list the contents of O, as a sentence, using the definite article.
To say a list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(0);
		@pull say__c; -).
To say list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(NOARTICLE_BIT);
		@pull say__c; -).
To say the list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(DEFART_BIT);
		@pull say__c; -).
To say The list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(-DEFART_BIT);
		@pull say__c; -).
To say is-are a list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(ISARE_BIT);
		@pull say__c; -).
To say is-are list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(ISARE_BIT+NOARTICLE_BIT);
		@pull say__c; -).
To say is-are the list of (OS - [specification] description):
	(- @push say__c;
		objectloop (say__c ofclass Object) if ({-bind-to-say__c:OS}) 
		give say__c i7listflag; else give say__c ~i7listflag;
		I7List(DEFART_BIT+ISARE_BIT);
		@pull say__c; -).
To group (OS - [specification] description) together
	(documented at ph_group):
	(- @push say__c;
		objectloop (say__c provides list_together) if ({-bind-to-say__c:OS}) 
		say__c.list_together = {-list-together};
		@pull say__c; -).
To group (OS - [specification] description) together giving articles:
	(- @push say__c;
		objectloop (say__c provides list_together) if ({-bind-to-say__c:OS}) 
		say__c.list_together = {-articled-list-together};
		@pull say__c; -).
To group (OS - [specification] description) together as (T - text):
	(- @push say__c;
		objectloop (say__c provides list_together) if ({-bind-to-say__c:OS}) 
		say__c.list_together = {T};
		@pull say__c; -).
To omit contents in listing
	(documented at ph_omit):
	(- c_style = c_style &~ (RECURSE_BIT+FULLINV_BIT+PARTINV_BIT); -).
To place (O - an object) in scope, but not its contents
	(documented at ph_scope):
	(- I7_PlaceInScope({O}, {phrase options}); -).


Section SR4/9a - The player's command

To decide if (S - a snippet) matches (T - a topic)
	(documented at act_reading):
	(- (I7_SnippetMatches({S}, {T})) -).
To decide if (S - a snippet) does not match (T - a topic)
	(documented at act_reading):
	(- (I7_SnippetMatches({S}, {T}) == false) -).
To decide if (S - a snippet) includes (T - a topic):
	(- (I7_match_snippet=I7_Match({T},{S})) -).
To decide if (S - a snippet) does not include (T - a topic):
	(- (I7_Match({T},{S})==0) -).
To replace (S - a snippet) with (T - text):
	(- I7_SpliceSnippet({S}, {T}); -).
To cut (S - a snippet):
	(- I7_SpliceSnippet({S}, 0); -).
To reject the player's command:
	(- RulebookFails(); rtrue; -).
To decide whether player consents
	(documented at ph_consents): 
		(- YesOrNo() -)


Section SR4/10 - Loops and conditionals

To if (c - condition) then (ph - phrase)
	(documented at ph_if):
	(- if {c} {ph} -).
To if (c - condition) , (ph - phrase):
	(- if {c} {ph} -).
[To otherwise if (c - condition) , (ph - phrase) -- in if:
	(- } else if {c} { if (true) {ph} -).
To else if (c - condition) , (ph - phrase) -- in if:
	(- } else if {c} { if (true) {ph} -).]
To otherwise if (c - condition) -- in if:
	(- } else if {c} { -).
To else if (c - condition) -- in if:
	(- } else if {c} { -).
To otherwise (ph - phrase)
	(documented at ph_otherwise):
	(- else {ph} -).
To else (ph - phrase)
	(documented at ph_otherwise):
	(- else {ph} -).
To if (c - condition) begin -- end:
	(- if {c}  -).
To while (c - condition) repeatedly (ph - phrase)
	(documented at ph_while):
	(- while {c} {ph} -).
To while (c - condition) , (ph - phrase):
	(- while {c} {ph} -).
To while (c - condition) begin -- end:
	(- while {c}  -).
To repeat with (loopvar - number variable)
	running from (v - number) to (w - number) begin -- end
	(documented at ph_repeat):
		(- for ({loopvar}={v}: {loopvar}<={w}: {loopvar}++)  -).
To repeat with (loopvar - object variable)
	running through (OS - description) begin -- end
	(documented at ph_runthrough):
		(- {-loop-over:OS}  -).
To issue the error (message - string-of-text):
	(- print ">--> ", (string) {message}, "^^"; rtrue; -).
To stop:
	(- return; -).
To yes
	(documented at ph_yes):
	(- rtrue; -) - condition.
To no:
	(- rfalse; -) - condition.
To decide on (something - value)
	(documented at ph_result):
	(- return {something}; -) - value.
To decide yes:
	(- rtrue; -) - condition.
To decide no:
	(- rfalse; -) - condition.
To decide whether using the/-- (UO - use-option):
	(- (I7ReadUseOption({UO})) -).


Section SR4/11 - Accessibility

To decide whether (o - object) is inaccessible, saying if not:
	(- (ObjectIsUntouchable({o}, ~~({saying if not}))) -).
[To allow access
	(documented at ph_allow):
	(- RulebookSucceeds(); rtrue; -).
To deny access:
	(- RulebookFails(); rtrue; -).]
[To there is sufficient light
	(documented at visibility):
	(- RulebookFails(); rtrue; -).
To there is insufficient light
	(documented at visibility):
	(- RulebookSucceeds(); rtrue; -).]
[To persuasion succeeds:
	(- RulebookSucceeds(); rtrue; -).
To persuasion fails:
	(- RulebookFails(); rtrue; -).]


Section SR4/13 - Fonts and visual effects

To say bold type -- running on
	(documented at ph_types):
	(- style bold; -).
To say italic type -- running on:
	(- style underline; -).
To say roman type -- running on:
	(- style roman; -).
To say fixed letter spacing -- running on:
	(- font off; -).
To say variable letter spacing -- running on:
	(- font on; -).
To display the boxed quotation (Q - boxed-quotation)
	(documented at ph_boxed):
	(- I7_box = {Q}; -).


Section SR4/14 - Following rules

To follow (RL - a rule)
	(documented at ph_follow):
	(- FollowRulebook({RL}); -).
To consider (RL - a rule)
	(documented at ph_consider):
	(- ProcessRulebook({RL}); -).
To abide by (RL - a rule):
	(- if (ProcessRulebook({RL})) rtrue; -).
To follow (RL - a rule) for (O - object):
	(- FollowRulebook({RL}, {O}, true); -).
To consider (RL - a rule) for (O - object):
	(- ProcessRulebook({RL}, {O}, true); -).
To abide by (RL - a rule) for (O - object):
	(- if (ProcessRulebook({RL}, {O}, true)) rtrue; -).


Section SR4/15 - Success and failure of rules

To make no decision: (- rfalse; -).
To rule succeeds
	(documented at ph_succeeds):
	(- RulebookSucceeds(); rtrue; -).
To rule fails:
	(- RulebookFails(); rtrue; -).
To rule succeeds with result (O - a miscellaneous-value):
	(- RulebookSucceeds(true,{O}); rtrue; -).
To rule fails with result (O - a miscellaneous-value):
	(- RulebookFails(true,{O}); rtrue; -).
To decide if rule succeeded:
	(- (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) -).
To decide if rule succeeded with result (O - miscellaneous-value):
	(- ((rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
		&& (rulechange_stack-->(rulechange_sp+1) == true)
		&& (rulechange_stack-->(rulechange_sp+2) == {O})) -).
To decide if rule failed:
	(- (rulechange_stack-->rulechange_sp == RS_FAILS) -).
To decide if rule failed with result (O - miscellaneous-value):
	(- ((rulechange_stack-->rulechange_sp == RS_FAILS)
		&& (rulechange_stack-->(rulechange_sp+1) == true)
		&& (rulechange_stack-->(rulechange_sp+2) == {O})) -).
To decide which miscellaneous-value is the result of the rule:
	(- (ResultOfRule()) -).
To decide which rulebook-outcome is the outcome of the rulebook:
	(- (ResultOfRule()) -).

Section SR4/16 - Procedural manipulation of rules

To ignore (RL - a rule)
	(documented at ph_ignore):
	(- SuppressRule({RL}); -).
To reinstate (RL - a rule):
	(- ReinstateRule({RL}); -).
To reject the result of (RL - a rule):
	(- DonotuseRule({RL}); -).
To accept the result of (RL - a rule):
	(- DonotuseRule({RL}); -).
To substitute (RL1 - a rule) for (RL2 - a rule):
	(- SubstituteRule({RL1},{RL2}); -).
To restore the original (RL1 - a rule):
	(- SubstituteRule({RL1},{RL1}); -).
To move (RL1 - a rule) to before (RL2 - a rule):
	(- MoveRuleBefore({RL1},{RL2}); -).
To move (RL1 - a rule) to after (RL2 - a rule):
	(- MoveRuleAfter({RL1},{RL2}); -).


Section SR4/17 - Unindexed

To decide whether the world model includes (O - an object):
	 (- (I7_OnStage({O})) -).
To decide whether the world model does not include (O - an object):
	 (- (I7_OnStage({O})==false) -).

To abide by I6 GamePreRoutine:
	(- if (GamePreRoutine()~=0) rtrue; -).
To abide by I6 orders property:
	(- if (RunRoutines(player,orders)~=0) rtrue; -).
To abide by I6 location before:
	(- if (location~=0 && RunRoutines(location,before)~=0) rtrue; -).
To abide by I6 react_before property:
	(- scope_reason=REACT_BEFORE_REASON; parser_one=0;SearchScope(ScopeCeiling(player),player,0); scope_reason=PARSING_REASON; if (parser_one~=0) rtrue; -).
To abide by I6 object before:
	(- if (inp1>1 && RunRoutines(inp1,before)~=0) rtrue; -).

To abide by I6 GamePostRoutine:
	(- if (GamePostRoutine()~=0) rtrue; -).
To abide by I6 location after:
	(- if (location~=0 && RunRoutines(location,after)~=0) rtrue; -).
To abide by I6 react_after property:
	(- scope_reason=REACT_AFTER_REASON; parser_one=0;SearchScope(ScopeCeiling(player),player,0); scope_reason=PARSING_REASON; if (parser_one~=0) rtrue; -).
To abide by I6 object after:
	(- if (inp1>1 && RunRoutines(inp1,after)~=0) rtrue; -).

To run scene change machinery:
	(- I7_SceneChange(); -).

To cause the action to take place:
	(- _I6_ActionPrimitive(); rtrue; -).

To cause the description to take place:
	(- I6_PSN__(parameter_object); -).
To cause the listing to take place:
	(- I7_WLF(child(parameter_object), 0); -).

To dump Z stack backtrace: (- @"EXT:132"; -).

The say-parameter is an object that varies.
The i6-nothing is an object that varies. [A lie: it's the constant "nothing".]

To decide whether parser error is didn't understand:
	(- (etype == STUCK_PE) -).
To decide whether parser error is only understood as far as:
	(- (etype == UPTO_PE) -).
To decide whether parser error is didn't understand that number:
	(- (etype == NUMBER_PE) -).
To decide whether parser error is can't see any such thing:
	(- (etype == CANTSEE_PE) -).
To decide whether parser error is said too little:
	(- (etype == TOOLIT_PE) -).
To decide whether parser error is aren't holding that:
	(- (etype == NOTHELD_PE) -).
To decide whether parser error is can't use multiple objects:
	(- (etype == MULTI_PE) -).
To decide whether parser error is can only use multiple objects:
	(- (etype == MMULTI_PE) -).
To decide whether parser error is not sure what it refers to:
	(- (etype == VAGUE_PE) -).
To decide whether parser error is excepted something not included:
	(- (etype == EXCEPT_PE) -).
To decide whether parser error is can only do that to something animate:
	(- (etype == ANIMA_PE) -).
To decide whether parser error is not a verb I recognise:
	(- (etype == VERB_PE) -).
To decide whether parser error is not something you need to refer to:
	(- (etype == SCENERY_PE) -).
To decide whether parser error is can't see it at the moment:
	(- (etype == ITGONE_PE) -).
To decide whether parser error is didn't understand the way that finished:
	(- (etype == JUNKAFTER_PE) -).
To decide whether parser error is not enough of those available:
	(- (etype == TOOFEW_PE) -).
To decide whether parser error is nothing to do:
	(- (etype == NOTHING_PE) -).
To decide whether parser error is I beg your pardon:
	(- (etype == BLANKLINE_PE) -).

Part SR5 - Bibliographic data - unindexed

The story title, the story author, the story headline, the story genre
and the story description are text variables.
The release number is a number variable. The story creation year is a number
variable.
Figure of cover is the file of cover art.

The Standard Rules end here.

---- DOCUMENTATION ----

Unlike other extensions, the Standard Rules are compulsorily included
with every project. They define the phrases, kinds and relations which
are basic to Inform, and which are described throughout the documentation.
